<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design Goals · PolynomialRings.jl</title><link rel="canonical" href="http://tkluck.github.io/PolynomialRings.jl/stable/design-goals.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PolynomialRings.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li class="current"><a class="toctext" href="design-goals.html">Design Goals</a><ul class="internal"><li><a class="toctext" href="#First-class-support-for-different-expansions-of-the-same-object-1">First-class support for different expansions of the same object</a></li><li><a class="toctext" href="#User-friendly-support-for-pools-of-indeterminate-variables-1">User-friendly support for pools of indeterminate variables</a></li><li><a class="toctext" href="#Speed-1">Speed</a></li><li><a class="toctext" href="#Use-elementary-Julia-types-wherever-possible-1">Use elementary Julia types wherever possible</a></li></ul></li><li><a class="toctext" href="other-packages.html">Other packages</a></li><li><a class="toctext" href="functions.html">Types and Functions</a></li><li><a class="toctext" href="reference.html">Reference Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="design-goals.html">Design Goals</a></li></ul><a class="edit-page" href="https://github.com/tkluck/PolynomialRings.jl.git"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Design Goals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Design-goals-1" href="#Design-goals-1">Design goals</a></h1><h2><a class="nav-anchor" id="First-class-support-for-different-expansions-of-the-same-object-1" href="#First-class-support-for-different-expansions-of-the-same-object-1">First-class support for different expansions of the same object</a></h2><p>We hope to make it exceedingly easy to regard, for example, a matrix of polynomials as a polynomial with matrix coefficients. Or to regard a polynomial in five variables with coefficients in ℚ as a two-variable polynomial with coefficients in the ring of three-variable polynomials over ℚ.</p><p>This makes the signature of some functions a bit different than usual. For example, a function call like</p><pre><code class="language-julia-repl">    coefficient(x^3 + x^2*y + y, y)</code></pre><p>is ambiguous: should the result be <code>1</code> or <code>x^2+1</code>? Most other computer algebra systems base their decision on the parent object for the polynomial: these two results are what one gets if it is, respectively, <code>ℚ[x,y]</code> or <code>ℚ[x][y]</code>.</p><p>We make a different choice: the variables relative to which one wants to take the expansion, need to be passed explicitly:</p><pre><code class="language-julia-repl">julia&gt; coefficient(x^3 + x^2*y + y, (1,), :y)
x^2 + 1
julia&gt; coefficient(x^3 + x^2*y + y, (0,1), :x, :y)
1</code></pre><p>At first glance, this may seem more cumbersome than usual. However, in a situation where one switches perspective regularly, the alternative is much harder to work with. This is because it is not obvious from the name of a variable <code>x</code> which parent object it belongs to.</p><p>Moreover, in practice, this choice does not sacrifice convenience at all, because the following macro is provided:</p><pre><code class="language-julia-repl">julia&gt; @coefficient(x^2 + x^2*y + y, y)
x^2 + 1
julia&gt; @coefficient(x^2 + x^2*y + y, x^0 * y)
1</code></pre><p>We (intend to) have similar &#39;relative&#39; versions of functions such as <code>expansion()</code>, <code>leading_term()</code> and <code>deg()</code>.</p><h2><a class="nav-anchor" id="User-friendly-support-for-pools-of-indeterminate-variables-1" href="#User-friendly-support-for-pools-of-indeterminate-variables-1">User-friendly support for pools of indeterminate variables</a></h2><p>It should be easy to generate a vector such as &quot;two instances of the most general polynomial of degree two&quot;:</p><pre><code class="language-none">[c1*x^2 + c2*x + c3, c4*x^2 + c5*x + c6 ]</code></pre><p>We make this possible by supporting polynomial rings with an unbounded number of variables and a sparse representation of the exponents. For example:</p><pre><code class="language-julia-repl">julia&gt; R = @ring! ℤ[c[]][x]
ℤ[c[]][x]
julia&gt; sum(c[i] * x^i for i in 1:5)
c[1] * x + c[2] * x^2 + c[3] * x^3 + c[4] * x^4 + c[5] * x^5</code></pre><h2><a class="nav-anchor" id="Speed-1" href="#Speed-1">Speed</a></h2><p>For elementary operations, we aim to get within the typical factor 2 for julia-vs-C when compared to Singular. At this point, this library has comparable performance to Singular on at least one simple benchmark:</p><pre><code class="language-none">$ julia &lt;&lt;JULIA
using PolynomialRings; using Singular
R = @ring! ℤ[d,e,f]
S,g,h,i = Singular.SingularPolynomialRing(Singular.SingularZZ, [&quot;g&quot;,&quot;h&quot;,&quot;i&quot;])
(d+e+f)^4; (g+h+i)^4 # compile all julia code
@time (d+e+f)^200
@time (g+h+i)^200
prod(d+e+f for _=1:5); prod(g+h+i for _=1:5) # compile all julia code
@time prod(d+e+f for _=1:200)
@time prod(g+h+i for _=1:200)
JULIA
  0.151427 seconds (1.51 M allocations: 40.430 MiB, 20.68% gc time)
  0.879622 seconds (13.50 M allocations: 319.072 MiB, 2.00% gc time)
  1.584750 seconds (31.07 M allocations: 896.958 MiB, 29.18% gc time)
  1.030947 seconds (14.87 M allocations: 373.402 MiB, 1.99% gc time)</code></pre><p>Note: the Singular code has some non-trivial Julia-overhead (as can be seen from the allocations), so this comparison isn&#39;t quite fair.</p><h2><a class="nav-anchor" id="Use-elementary-Julia-types-wherever-possible-1" href="#Use-elementary-Julia-types-wherever-possible-1">Use elementary Julia types wherever possible</a></h2><p>For example, for any function operating on free finitely generated modules, the module elements should just be represented by <code>AbstractArray{&lt;:Polynomial}</code> or <code>Dict{K,&lt;:Polynomial}</code>. Polynomial coefficients can be any <code>Number</code>, any <code>Array</code> (for expansions in a module), or any <code>Matrix</code> (for a polynomial ring with matrix coefficients).</p><p>A module element can be any <code>AbstractArray</code>, not necessarily an <code>AbstractVector</code>. That also means that if we need to represent a finite set of module elements, we use <code>AbstractVector{&lt;:AbstractVector}</code>, not an <code>AbstractMatrix</code>. This makes it easier to work with matrix spaces: e.g. solving matrix equations <code>a*x + x*a = y</code> over polynomial rings using Gröbner basis methods.</p><footer><hr/><a class="previous" href="getting-started.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="other-packages.html"><span class="direction">Next</span><span class="title">Other packages</span></a></footer></article></body></html>
